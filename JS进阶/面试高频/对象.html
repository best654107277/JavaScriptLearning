<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>


<script>
    // "use strict"   //严格模式
    // let person = {}
    // Object.defineProperty(person,"name",{
    //     // writable:false, //只读
    //     configurable:false, //是否可以修改
    //     value:'csj'
    // })
    //
    // console.log(person.name);
    // person.name = 'csja' //严格模式下会报错
    // console.log(person.name);
    // delete person.name
    // console.log(person.name);


    // let book = {
    //     year_:2017,
    //     edition:1
    // }

    // let person ={
    //     "name":'aaa'
    // }
    // let myName = 'name'
    // console.log(person.name);
    // console.log(person['name'])


    //普通的对象创建方法
    // let obj = {
    //     name:'csj',
    //     age:18,
    //     set:function(){
    //         console.log(this.name)
    //     }
    // }
    //
    // obj.name = 'csj god'


    //构造和原型混合模式
    // function CreatePerson(name,age,address){
    //     this.name = name
    //     this.age = age
    //     this.address = address
    // }
    //
    // CreatePerson.prototype.getName = function(){
    //     return this.name
    // }
    //
    // let csj = new CreatePerson('csj',18,{
    //     name:'广西',
    //     code:"000"
    // })
    // let ly = new CreatePerson('ly',18,{
    //     name:'广西',
    //     code:'000'
    // })
    // console.log(csj);
    // console.log(ly);
    // console.log(CreatePerson.prototype === ly.__proto__);

    //动态原型创建模式
    // function Person(name,age,address){
    //     this.name = name
    //     this.age = age
    //     this.address = address
    //
    //     if(typeof Person._initialized === 'undefined'){
    //         Person.prototype.getName = function(){
    //             return this.name
    //         }
    //     Person._initialized = true
    //     }
    // }
    // let csj = new Person('csj',18,{
    //     name:'广西',
    //     code:"000"
    // })
    // let ly = new Person('ly',18,{
    //     name:'广西',
    //     code:'000'
    // })
    // console.log(csj.getName());
    // console.log(ly.getName());


    //浅拷贝
    // let origin = {
    //     a:1,
    //     b:[2,3,4],
    //     c:{
    //         d:'name'
    //     }
    // }
    // let obj = origin
    // console.log(obj)

    // function showClone(origin){
    //     let result = {}
    //     for(const key in origin){
    //         if(origin.hasOwnProperty(key)){
    //             result[key] = origin[key]
    //         }
    //     }
    //     return result
    // }
    // let newObj = showClone(origin)
    // newObj.b[2] = 5
    // console.log(newObj);
    // console.log(origin);

    //ES6新增 assign方法  还是浅拷贝
    // let result = Object.assign({},origin)
    // result.b[1] = 5
    // console.log(result);
    // console.log(origin);


    //深拷贝
    // 1.JSON序列化和反序列化
    // 这种方法不能处理对函数,regexp等特殊对象
    //对象的constructor会被抛弃,所有的构造函数指向Object,原型链关系会破裂
    //对象中如果存在循环引用,就会抛出异常
    // let origin = {
    //     a:1,
    //     b:[2,3,4],
    //     c:{
    //         d:'name'
    //     }
    // }
    // let result = JSON.parse(JSON.stringify(origin))
    // // console.log(result);
    // result.b[0] = 6
    // console.log(result);
    // console.log(origin);


    //自定义深拷贝方法
    //模拟其他类库对外暴露接口的方式 _
    // (function(_){
    //
    //     //列出所有的数据类型
    //     let types = 'Array Object String Date RegExp Number Boolean Null Undefined'.split(' ')
    //     console.log(types);
    //
    //     function type(){
    //     //模拟JS中isArray()方法
    //
    //     }
    //
    //     for (let i = 0; i < types.length; i++) {
    //         _['is'+types[i]] = (function(){
    //             return function(elem){
    //                 console.log(elem)
    //                 return type.call(elem)
    //             }
    //         })(types[i])
    //
    //     }
    //     return _
    // })(_={})

    //继承
    //父类
    // function Animal(name){
    //     this.type = 'animal'
    //     this.name = name||'动物'
    //
    //     //方法
    //     this.sleep = function(){
    //         console.log(this.name + '正在睡觉')
    //     }
    // }
    //
    // //原型链上的属性和方法
    // Animal.prototype.age = 1
    // Animal.prototype.eat = function(food){
    //     console.log(this.name + '正在吃饭'+food)
    // }
    //
    // //原型链继承 子类
    // function Cat(name){
    //     this.name = name
    // }
    // //原型链继承
    // Cat.prototype = new Animal()
    //
    // let cat = new Cat('加菲猫')
    // cat.eat()
    //
    //
    // let dog = new Animal('dog')
    //
    // console.log(dog);


    // //父类
    // function Animal(name){
    //     this.name = name
    //     this.age = 15
    //     this.sleep = function(){
    //         console.log(this.name+': 正在睡觉')
    //     }
    // }
    // //父类的原型上增加方法
    // Animal.prototype.eat = function(food){
    //     console.log(this.name+'正在吃'+food)
    // }
    //
    // //子类
    // function Cat(name){
    //     Animal.call(this)
    //     this.name = name
    // }
    // let cat = new Cat('加菲猫')
    // console.log(cat.age);
    // cat.sleep()
    // cat.eat()


    // //定义父类
    // function Animal(name,age){
    //     this.name = name
    //     this.age = age
    //     this.sleep = function(){
    //         console.log(this.name + '正在睡觉')
    //     }
    // }
    // Animal.prototype.eat = function(food){
    //     console.log(this.name + '正在吃' + food)
    // }
    // //子类
    // function Cat(name,age){
    //     Animal.call(this)
    //     this.name = name
    //     this.age = age
    // }
    //
    // //原型链继承
    // Cat.prototype = new Animal()
    //
    // //绑定到自己身上
    // Cat.prototype.constructor = Cat
    //
    // let cat = new Cat('csj',777)
    // console.log(cat.name,cat.age);
    // cat.eat('鸡肉')
    //
    // let animal = new Animal('ly',777)
    // animal.eat('鸡肉')


    //定义父类
    function Animal(name,age){
        this.name = name
        this.age = age
        this.sleep = function(){
            console.log(this.name+'正在睡觉');
        }
        this.feature = ['fat','thin','tall']
    }

    //原型函数
    Animal.prototype.eat = function(food){
        console.log(this.name+'正在吃'+food)
    }

    //子类
    function Cat (name,age){
        Animal.call(this)
        this.name = name
        this.age = age
    }

    //原型的两次绑定加入函数去处理控制
    (function(){
         let Super = function(){}
        Super.prototype = Animal.prototype
        Cat.prototype = new Super()
        Cat.prototype.constructor = Cat
    })()
    let cat = new Cat('tom',20)
    console.log(cat);
    cat.eat('meat')

    let animal = new Animal('csj',26)
    console.log(animal);
    animal.eat('西餐')
    console.log(cat.feature[0]);
    console.log(cat.age);


</script>
</body>
</html>